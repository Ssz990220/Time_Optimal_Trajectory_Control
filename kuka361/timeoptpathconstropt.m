function [a, b, c, d, tau, bvar, cvar, dvar, F, t, diagnostics] = timeoptpathconstropt(s, sm, ds, q, qp, qpp, Mv, Cv, gv, torquelb, torqueub, gamma1, gamma2, solver)
%***************************************************************************
%  tag: Diederik Verscheure  di jun 12 15:28:22 CEST 2007  timeoptpathconstropt.m
%
%                           timeoptpathconstropt.m -  description
%                           ----------------------------
%    begin                : di juni 12 2007
%    copyright            : (C) 2007 K.U.Leuven
%    email                : diederik <dot> verscheure <at> mech <dot> kuleuven <dot> be
%
% This program is free software: you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation, either version 3 of the License, or
% (at your option) any later version.
% 
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
% 
% You should have received a copy of the GNU General Public License
% along with this program.  If not, see <http://www.gnu.org/licenses/>.

% ***************************************************************************
% Purpose
% ---------------------------------------------------------------------------
% Solves the time-optimal trajectory planning problem.
% 
% ***************************************************************************
% [A, B, C, D, TAU, BVAR, CVAR, DVAR, F, T, DIAGNOSTICS] = TIMEOPTPATHCONSTROPT(S, SM, DS, Q, QP, QPP, MV, CV, GV, TORQUELB, TORQUEUB, GAMMA1, GAMMA2, SOLVER)
%
% INPUTS
% ----------------------
% The first 9 inputs should be generated by DYNPATHPARAMS.
% S: s grid row vector.
% SM: s midpoints row vector.
% DS: ds row vector.
% Q, QP, QPP: q, q' and q'' as a function of sm.
% MV, CV, GV: the mass, coriolis and gravity term as a function of
%             q, q' and q'' evaluated on sm.
%
%
% TORQUELB: torque lower bound (column vector). Dimension should be equal to system DOFS.
% TORQUEUB: torque upper bound (column vector). Dimension should be equal to system DOFS.
% GAMMA1: weighting on the integral of the square of the torques.
% GAMMA2: weighting on the integral of the absolute value of the rate of change of the torque.
% SOLVER: the solver to be used.
%
% OUTPUTS
% ----------------------
% A: sddot evaluated on the midpoints of the s grid (row vector).
% B: sdot^2 evaluated on the s grid (row vector) with beginning and end equal to zero.
% C: slack variables evaluated on the s grid (row vector) except at beginning and end.
% D: slack variables evaluated on the midpoints of the s grid (row vector)
% TAU: tau evaluated on the midpoints of the s grid (matrix).
% BVAR: corresponding sdp variable
% CVAR: corresponding sdp variable
% DVAR: corresponding sdp variable
% F: the constraint set
% t: the objective function

% ------------------------------------------------------
% |                   INITIALISATION                   |
% ------------------------------------------------------

% System DOFS
nrdof = size(torquelb,1);
	
% Number of optimization variables
% --------------------------------
% 1) The b's.
% 2) Slack variables c's.
% 3) Slack variables d's.
% 4) Slack variables e's.
nrb = length(s)-2;
% For each b one slack variable c, except for begin and end
nrc = nrb;
nrd = length(s)-1;
% nrdof x nre is total number of e variables!
nre = nrb;

% Linear inequalities
% -------------------
% 1) Lower bounds on torques
% 2) Upper bounds on torques
% 3) Related to slack variables e
nrtorquelbineq = nrdof*nrd;
nrtorqueubineq = nrdof*nrd;
nrslackeineq = nrdof*nre*2;

% Linear matrix or cone inequalities
% ----------------------------------
% 1) Related to slack variables c
% 2) Related to slack variables d
nrslackcineq = nrc;
nrslackdineq = nrd;

fprintf('-----------------------------------------------------------------------------\n');
fprintf('Note: the current implementation has a considerable setup time due to        \n');
fprintf('      multiple (unnecessary) loops and concatenation of constraints.         \n');
fprintf('      This is done merely to allow for readable code. Setup time can be      \n');
fprintf('      reduced drastically by not using YALMIP....                            \n');
fprintf('-----------------------------------------------------------------------------\n');

% ------------------------------------------------------
% |                     SOLUTION                       |
% ------------------------------------------------------
% Generate variables
% ------------------
fprintf('Allocating optimization variables...\n');
bvar = sdpvar(1,nrb);
cvar = sdpvar(1,nrc);
dvar = sdpvar(1,nrd);
if gamma2 ~= 0
	% Specify full to avoid accidentally obtaining a symmetric matrix
	evar = sdpvar(nrdof,nre,'full');
end
fprintf('Done allocating optimization variables...\n');

% Set implementation
% ------------------
F = set([]);

fprintf('Generating torque constraints...\n');
% 1) Inequality constraints
% Note: b is zero at the boundaries
F = F + set((Mv(:,1)*(bvar(1,1)-0)/(2*ds(1)) + Cv(:,1)*(0 + bvar(1,1))/2 + gv(:,1))./torqueub <= torqueub./torqueub);
F = F + set((Mv(:,1)*(bvar(1,1)-0)/(2*ds(1)) + Cv(:,1)*(0 + bvar(1,1))/2 + gv(:,1))./torqueub >= torquelb./torqueub);
for k = 2:nrd-1
	F = F + set((Mv(:,k)*(bvar(1,k)-bvar(1,k-1))/(2*ds(k)) + Cv(:,k)*(bvar(1,k-1)+bvar(1,k))/2 + gv(:,k))./torqueub <= torqueub./torqueub);
	F = F + set((Mv(:,k)*(bvar(1,k)-bvar(1,k-1))/(2*ds(k)) + Cv(:,k)*(bvar(1,k-1)+bvar(1,k))/2 + gv(:,k))./torqueub >= torquelb./torqueub);
end
% Note: b is zero at the boundaries
F = F + set((Mv(:,nrd)*(0-bvar(1,nrd-1))/(2*ds(nrd)) + Cv(:,nrd)*(bvar(1,nrd-1)+0)/2 + gv(:,nrd))./torqueub <= torqueub./torqueub);
F = F + set((Mv(:,nrd)*(0-bvar(1,nrd-1))/(2*ds(nrd)) + Cv(:,nrd)*(bvar(1,nrd-1)+0)/2 + gv(:,nrd))./torqueub >= torquelb./torqueub);
fprintf('Done generating torque constraints...\n');


fprintf('Generating absolute value constraints...\n');
if gamma2 ~= 0
	F = F + set(((Mv(:,2)*(bvar(1,2)-bvar(1,1))/(2*ds(2)) + Cv(:,2)*(bvar(1,1)+bvar(1,2))/2 + gv(:,2)) - (Mv(:,1)*(bvar(1,1)-0)/(2*ds(1)) + Cv(:,1)*(0+bvar(1,1))/2 + gv(:,1)))./torqueub <= evar(:,1));
	F = F + set(-evar(:,1) <= ((Mv(:,2)*(bvar(1,2)-bvar(1,1))/(2*ds(2)) + Cv(:,2)*(bvar(1,1)+bvar(1,2))/2 + gv(:,2)) - (Mv(:,1)*(bvar(1,1)-0)/(2*ds(1)) + Cv(:,1)*(0+bvar(1,1))/2 + gv(:,1)))./torqueub);
	for k = 2:nre-1
		F = F + set(((Mv(:,k+1)*(bvar(1,k+1)-bvar(1,k))/(2*ds(k+1)) + Cv(:,k+1)*(bvar(1,k)+bvar(1,k+1))/2 + gv(:,k+1)) - (Mv(:,k)*(bvar(1,k)-bvar(1,k-1))/(2*ds(k)) + Cv(:,k)*(bvar(1,k-1)+bvar(1,k))/2 + gv(:,k)))./torqueub <= evar(:,k));
		F = F + set(-evar(:,k) <= ((Mv(:,k+1)*(bvar(1,k+1)-bvar(1,k))/(2*ds(k+1)) + Cv(:,k+1)*(bvar(1,k)+bvar(1,k+1))/2 + gv(:,k+1)) - (Mv(:,k)*(bvar(1,k)-bvar(1,k-1))/(2*ds(k)) + Cv(:,k)*(bvar(1,k-1)+bvar(1,k))/2 + gv(:,k)))./torqueub);
	end
	F = F + set(((Mv(:,nre+1)*(0-bvar(1,nre))/(2*ds(nre+1)) + Cv(:,nre+1)*(bvar(1,nre)+0)/2 + gv(:,nre+1)) - (Mv(:,nre)*(bvar(1,nre)-bvar(1,nre-1))/(2*ds(nre)) + Cv(:,nre)*(bvar(1,nre-1)+bvar(1,nre))/2 + gv(:,nre)))./torqueub <= evar(:,nre));
	F = F + set(-evar(:,nre) <= ((Mv(:,nre+1)*(0-bvar(1,nre))/(2*ds(nre+1)) + Cv(:,nre+1)*(bvar(1,nre)+0)/2 + gv(:,nre+1)) - (Mv(:,nre)*(bvar(1,nre)-bvar(1,nre-1))/(2*ds(nre)) + Cv(:,nre)*(bvar(1,nre-1)+bvar(1,nre))/2 + gv(:,nre)))./torqueub);
end
fprintf('Done generating absolute value constraints...\n');

fprintf('Generating cone constraints...\n');
% 3) Cone constraints
% Note: b and c is zero at the boundaries
F = F + set(cone([2; 2*sqrt(gamma1)*(Mv(:,1)*(bvar(1,1)-0)/(2*ds(1)) + Cv(:,1)*(0 + bvar(1,1))/2 + gv(:,1))./torqueub; 0 + cvar(1,1)-dvar(1,1)], 0 + cvar(1,1) + dvar(1,1)));
for k = 2:nrd-1
	F = F + set(cone([2; 2*sqrt(gamma1)*(Mv(:,k)*(bvar(1,k)-bvar(1,k-1))/(2*ds(k)) + Cv(:,k)*(bvar(1,k-1)+bvar(1,k))/2 + gv(:,k))./torqueub; cvar(1,k-1)+cvar(1,k)-dvar(1,k)], cvar(1,k-1)+cvar(1,k) + dvar(1,k)));
end
% Note: b and c is zero at the boundaries
F = F + set(cone([2; 2*sqrt(gamma1)*(Mv(:,nrd)*(0-bvar(1,nrd-1))/(2*ds(nrd)) + Cv(:,nrd)*(bvar(1,nrd-1)+0)/2 + gv(:,nrd))./torqueub; cvar(1,nrd-1)+0-dvar(1,nrd)], cvar(1,nrd-1) + 0 + dvar(1,nrd)));

for k = 1:nrc
	F = F + set(cone([2*cvar(1,k); bvar(1,k)-1], bvar(1,k)+1));
end
fprintf('Done generating cone constraints...\n');

fprintf('Generating objective function...\n');
% 4) Objective function
t = sum(dvar.*ds); 

if gamma2 ~= 0
	t = t + gamma2*sum(sum(evar));
end
fprintf('Done generating objective function...\n');

fprintf('Starting solver...\n');
sdpopt = sdpsettings('solver',solver);
diagnostics = solvesdp(F,t,sdpopt)
fprintf('Solver ended...\n');

b = double(bvar);
tau = zeros(nrdof,nrd);
tau(:,1) = (Mv(:,1)*(b(1,1)-0)/(2*ds(1)) + Cv(:,1)*(0 + b(1,1))/2 + gv(:,1));
for k = 2:nrd-1
        tau(:,k) = (Mv(:,k)*(b(1,k)-b(1,k-1))/(2*ds(k)) + Cv(:,k)*(b(1,k-1)+b(1,k))/2 + gv(:,k));
end
tau(:,nrd) = (Mv(:,nrd)*(0-b(1,nrd-1))/(2*ds(nrd)) + Cv(:,nrd)*(b(1,nrd-1)+0)/2 + gv(:,nrd));

b = [0 b 0];
a = (b(2:end)-b(1:end-1))./ds;
c = double(cvar);
d = double(dvar);

if diagnostics.problem == 0
	fprintf('Succesfully solved problem: objective value %.4f...\n', double(t));
else
	fprintf('Error obtaining solution: objective value %.4f...\n', double(t));
end

