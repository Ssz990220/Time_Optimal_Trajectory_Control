function [a, b, c, d, tau, bvar, cvar, dvar, tauvar, F, t, diagnostics] = timeoptpathconstr(s, sm, ds, q, qp, qpp, Mv, Cv, gv, torquelb, torqueub, gamma1, gamma2, solver)
%***************************************************************************
%  tag: Diederik Verscheure  di jun 12 15:28:22 CEST 2007  timeoptpathconstr.m
%
%                           timeoptpathconstr.m -  description
%                           ----------------------------
%    begin                : di juni 12 2007
%    copyright            : (C) 2007 K.U.Leuven
%    email                : diederik <dot> verscheure <at> mech <dot> kuleuven <dot> be
%
% This program is free software: you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation, either version 3 of the License, or
% (at your option) any later version.
% 
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
% 
% You should have received a copy of the GNU General Public License
% along with this program.  If not, see <http://www.gnu.org/licenses/>.

% ***************************************************************************
% Purpose
% ---------------------------------------------------------------------------
% Solves the time-optimal trajectory planning problem.
% 
% ***************************************************************************
% [A, B, C, D, TAU, BVAR, CVAR, DVAR, TAUVAR, F, T, DIAGNOSTICS] = TIMEOPTPATHCONSTR(S, SM, DS, Q, QP, QPP, MV, CV, GV, TORQUELB, TORQUEUB, GAMMA1, GAMMA2, SOLVER)
%
% INPUTS
% ----------------------
% The first 9 inputs should be generated by DYNPATHPARAMS.
% S: s grid row vector.
% SM: s midpoints row vector.
% DS: ds row vector.
% Q, QP, QPP: q, q' and q'' as a function of sm.
% MV, CV, GV: the mass, coriolis and gravity term as a function of
%             q, q' and q'' evaluated on sm.
%
%
% TORQUELB: torque lower bound (column vector). Dimension should be equal to system DOFS.
% TORQUEUB: torque upper bound (column vector). Dimension should be equal to system DOFS.
% GAMMA1: weighting on the integral of the square of the torques.
% GAMMA2: weighting on the integral of the absolute value of the rate of change of the torque.
% SOLVER: the solver to be used.
%
% OUTPUTS
% ----------------------
% A: sddot evaluated on the midpoints of the s grid (row vector).
% B: sdot^2 evaluated on the s grid (row vector) with beginning and end equal to zero.
% C: slack variables evaluated on the s grid (row vector) except at beginning and end.
% D: slack variables evaluated on the midpoints of the s grid (row vector)
% TAU: tau evaluated on the midpoints of the s grid (matrix).
% BVAR: corresponding sdp variable
% CVAR: corresponding sdp variable
% DVAR: corresponding sdp variable
% TAUVAR: corresponding sdp variable
% F: the constraint set
% t: the value of the objective function

% ------------------------------------------------------
% |                   INITIALISATION                   |
% ------------------------------------------------------

% System DOFS
nrdof = size(torquelb,1);
	
% Number of optimization variables
% --------------------------------
% 1) The b's.
% 2) The tau's.
% 3) Slack variables c's.
% 4) Slack variables d's.
% 5) Slack variables e's.
nrb = length(s)-2;
% nrdof x nrtau is total number of tau variables!
nrtau = length(s)-1;
% For each b one slack variable c, except for begin and end
nrc = nrb;
nrd = nrtau;
% nrdof x nre is total number of e variables!
nre = nrb;

% Linear equalities
% -----------------
% 1) Dynamic model constraints.
nrdynmodconstr = nrdof*nrtau;

% Linear inequalities
% -------------------
% 1) Lower bounds on torques
% 2) Upper bounds on torques
% 3) Related to slack variables e
nrtorquelbineq = nrdof*nrtau;
nrtorqueubineq = nrdof*nrtau;
nrslackeineq = nrdof*nre*2;

% Linear matrix or cone inequalities
% ----------------------------------
% 1) Related to slack variables c
% 2) Related to slack variables d
nrslackcineq = nrc;
nrslackdineq = nrd;

fprintf('-----------------------------------------------------------------------------\n');
fprintf('Note: the current implementation has a considerable setup time due to        \n');
fprintf('      multiple (unnecessary) loops and concatenation of constraints.         \n');
fprintf('      This is done merely to allow for readable code. Setup time can be      \n');
fprintf('      reduced drastically by not using YALMIP....                            \n');
fprintf('-----------------------------------------------------------------------------\n');

% ------------------------------------------------------
% |                     SOLUTION                       |
% ------------------------------------------------------
% Generate variables
% ------------------
fprintf('Allocating optimization variables...\n');
bvar = sdpvar(1,nrb);
% Specify full to avoid accidentally obtaining a symmetric matrix
% Note: tauvar are the torques divided by torqueub
tauvar = sdpvar(nrdof,nrtau,'full');
cvar = sdpvar(1,nrc);
dvar = sdpvar(1,nrd);
if gamma2 ~= 0
	% Specify full to avoid accidentally obtaining a symmetric matrix
	evar = sdpvar(nrdof,nre,'full');
end
fprintf('Done allocating optimization variables...\n');

% Set implementation
% ------------------
F = set([]);

fprintf('Generating dynamic constraints...\n');
% 1) Equality constraints
% Note: b is zero at the boundaries
% Note: tauvar are the torques divided by torqueub
F = F + set(torqueub.*tauvar(:,1) == Mv(:,1)*(bvar(1,1)-0)/(2*ds(1)) + Cv(:,1)*(0 + bvar(1,1))/2 + gv(:,1));
for k = 2:nrtau-1
	% Note: tauvar are the torques divided by torqueub
	F = F + set(torqueub.*tauvar(:,k) == Mv(:,k)*(bvar(1,k)-bvar(1,k-1))/(2*ds(k)) + Cv(:,k)*(bvar(1,k-1)+bvar(1,k))/2 + gv(:,k));
end
% Note: b is zero at the boundaries
% Note: tauvar are the torques divided by torqueub
F = F + set(torqueub.*tauvar(:,nrtau) == Mv(:,nrtau)*(0-bvar(1,nrtau-1))/(2*ds(nrtau)) + Cv(:,nrtau)*(bvar(1,nrtau-1)+0)/2 + gv(:,nrtau));
fprintf('Done generating dynamic constraints...\n');

fprintf('Generating torque constraints...\n');
% 2) Inequality constraints
for k = 1:nrtau
	% Note: tauvar are the torques divided by torqueub
	F = F + set(tauvar(:,k) <= torqueub./torqueub);
	F = F + set(tauvar(:,k) >= torquelb./torqueub);
end
fprintf('Done generating torque constraints...\n');

fprintf('Generating absolute value constraints...\n');
if gamma2 ~= 0
	for k = 1:nre
		% Note: tauvar are the torques divided by torqueub
		F = F + set((tauvar(:,k+1) - tauvar(:,k)) <= evar(:,k));
		F = F + set(-evar(:,k) <= (tauvar(:,k+1) - tauvar(:,k)));
	end
end
fprintf('Done generating absolute value constraints...\n');

fprintf('Generating cone constraints...\n');
% 3) Cone constraints
% Note: c is zero at the boundaries
F = F + set(cone([2; 2*sqrt(gamma1)*tauvar(:,1); 0 + cvar(1,1)-dvar(1,1)], 0 + cvar(1,1) + dvar(1,1)));
for k = 2:nrd-1
	F = F + set(cone([2; 2*sqrt(gamma1)*tauvar(:,k); cvar(1,k-1)+cvar(1,k)-dvar(1,k)], cvar(1,k-1)+cvar(1,k) + dvar(1,k)));
end
% Note: c is zero at the boundaries
F = F + set(cone([2; 2*sqrt(gamma1)*tauvar(:,nrtau); cvar(1,nrtau-1)+0-dvar(1,nrtau)], cvar(1,nrtau-1) + 0 + dvar(1,nrtau)));

for k = 1:nrc
	F = F + set(cone([2*cvar(1,k); bvar(1,k)-1], bvar(1,k)+1));
end
fprintf('Done generating cone constraints...\n');

fprintf('Generating objective function...\n');
% 4) Objective function
t = sum(dvar.*ds); 

if gamma2 ~= 0
	t = t + gamma2*sum(sum(evar));
end
fprintf('Done generating objective function...\n');

fprintf('Starting solver...\n');
sdpopt = sdpsettings('solver',solver);
diagnostics = solvesdp(F,t,sdpopt)
fprintf('Solver ended...\n');

b = double(bvar);
b = [0 b 0];
a = (b(2:end)-b(1:end-1))./ds;
% Multiply with torqueub to obtain the actual torques
tau = double(tauvar).*repmat(torqueub,1,nrtau);
c = double(cvar);
d = double(dvar);

if diagnostics.problem == 0
	fprintf('Succesfully solved problem: objective value %.4f...\n', double(t));
else
	fprintf('Error obtaining solution: objective value %.4f...\n', double(t));
end

